# JavaScript核心原理解析

## delete 0：JavaScript中到底有什么是可以销毁的

**习惯中的“引用”**

早期的 JavaScript 在推广时，采用传统的数据类型分类即值类型和引用类型，并且，所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的。

但是什么是引用类型呢？在这件事上，JavaScript 偷了个懒，它强行定义了“Object 和 Function 就是引用类型”。这样一来，引用类型和值类型就给开发人员讲清楚了，对象和函数呢，也就可以理解了：它们按引用来传递和使用。

绝大多数情况下，这样解释是可行的。但是到了 delete 运算这里，就不行。因为这样一来，`delete 0` 就是删除一个值，而 `delete x` 就既可能是删除一个值，也可能是删除一个引用。然而，当时 JavaScript 又同时约定：那些在 global 对象上声明的属性，就“等同于”全局变量。于是，这就带来了第三个问题：`delete x` 还可能是删除一个 global 对象上的属性。而它在执行这个操作的时候，看起来却像是一个全局变量（的名字）。

**到底在删除什么？**

```js
delete obj.x
```

`obj.x`既不是之前说过的引用类型，也不是之前说过的值类型，它与`typeof(x)`识别的所有类型都无关。因为，它是一个表达式。所以，`delete` 这个操作的正式语法设计并不是“删除某个东西”，而是“删除一个表达式的结果”：

**表达式的结果是什么？**

在 JavaScript 中，有两个东西可以被执行并存在执行结果值（Result），包括语句和表达式。比如你用`eval()`来执行一个字符串，那么事实上，你执行的是一个语句，并返回了语句的值；而如果你使用一对括号来强制一个表达式执行，那么这个括号运算得到的，就是这个表达式的值。表达式的值，在 ECMAScript 的规范中，称为“引用”。

```js
delete 0
```

事实上是在说：JavaScript 将 0 视为一个表达式，并尝试删除它的求值结果。

所以，现在这里的 0，其实不是值（Value）类型的数据，而是一个表达式运算的结果值（Result）。而在进一步的删除操作之前，JavaScript 需要检测这个 Result 的类型：

- 如果它是值，则按照传统的 JavaScript 的约定返回 true；
- 如果它是一个引用，那么对该引用进行分析，以决定如何操作。

这个检测过程说明，ECMAScript 约定：任何表达式计算的结果（Result）要么是一个值，要么是一个引用。并且需要留意的是，在这个描述中，所谓对象，其实也是值。准确地说，是“非引用类型”。

**总结**

- delete 运算符尝试删除值数据时，会返回 true，用于表示没有错误（Error）。
- delete 0 的本质是删除一个表达式的值（Result）。
- delete x 与上述的区别只在于 Result 是一个引用（Reference）。
- delete 其实只能删除一种引用，即对象的成员（Property）。

所以，只有在`delete x`等值于`delete obj.x`时 delete 才会有执行意义。例如`with (obj) ...`语句中的 `delete x`，以及全局属性 `global.x`。

## var x = y = 100：声明语句与语法改变了JavaScript语言核心性质

**声明**

严格意义上讲，JavaScript 只有变量和常量两种标识符，六条声明语句中：

- `let x` 声明变量 x。不可在赋值之前读。
- `const x` 声明常量 x。不可写。
- `var x` 声明变量 x。在赋值之前可读取到 undefined 值。
- `function x` 声明变量 x。该变量指向一个函数。
- `class x` 声明变量 x。该变量指向一个类（该类的作用域内部是处理严格模式的）。
- `import …` 导入标识符并作为常量（可以有多种声明标识符的模式和方法）。

除了这六个语句之外，还有两个语句有潜在的声明标识符的能力，不过它们并不是严格意义上的声明语句（声明只是它们的语法效果）。这两个语句是指：

- `for (var|let|constx…) …` for 语句有多种语法来声明一个或多个标识符，用作循环变量。
- `try … catch (x) …` catch 子句可以声明一个或多个标识符，用作异常对象变量。

总的来说，除上述的语法，用户是没有其它方式来在当前的代码上下文中“声明”出一个标识符来的。所有的“声明”：

> - 都意味着 JavaScript 将可以通过“静态”语法分析发现那些声明的标识符；
> - 标识符对应的变量 / 常量“一定”会在用户代码执行前就已经被创建在作用域中。

**发生了什么？**

回到讨论的这行代码`var x = y = 100`，在这行代码中，等号的右边是一个表达式`y = 100`，它发生了一次“向不存在的变量赋值”，所以它隐式地声明了一个全局变量y，并赋值为 100。
而一个赋值表达式操作的本身也是有“结果（Result）”的，它是右操作数的值。注意，这里是“值”而非“引用”，例如下面的测试中的a将是一个函数，而不是带着“this 对象”信息的方法：

```js
// 调用 obj.f() 时将检测 this 是不是原始的 obj
> obj = { f: function() { return this === obj } };
// false，表明赋值表达式的“结果 (result)”只是右侧操作数的值，即函数 f
> (a = obj.f)();
false
```

我们讲述了整个语句的过程，也就是说，由于“y = 100”的结果值是 100，所以该值将作为初始值赋值“变量 x”。并且，从语义上来说，这是变量“x”的初始绑定。

之所以强调这一点，是因为相同的分析过程也可以用在 const 声明上，而 const 声明是只有一次绑定的，常量的初始绑定也是通过“执行赋值过程”来实现的。

**总结**

- var 等声明语句总是在变量作用域（变量表）或词法作用域中静态地声明一个或多个标识符。
- 全局变量的管理方式决定了“向一个不存在的变量赋值”所导致的变量泄露是不可避免的。
- 动态添加的“var 声明”是可以删除的，这是唯一能操作 varNames 列表的方式（不过它并不存在多少实用意义）。
- 变量声明在引擎的处理上被分成两个部分：一部分是静态的、基于标识符的词法分析和管理，它总是在相应上下文的环境构建时作为名字创建的；另一部分是表达式执行过程，是对上述名字的赋值，这个过程也称为绑定。
- 标题里的这行代码中，x 和 y 是两个不同的东西，前者是声明的名字，后者是一个赋值过程可能创建的变量名。

## a.x = a = {n:2}：一道被无数人无数次地解释过的经典面试题

```js
var a = {n:1}
a.x = a = {n:2}
```

上面发生了两次赋值，第一次赋值发生于“a = {n: 2}”，它覆盖了“原始的变量a；第二次赋值发生于被”a.x”引用暂存的“原始的变量a”。

这里给出一段简单的代码，来复现这个现场，以便看清这个结果。例如：

```js
// 声明“原始的变量 a”
var a = {n:1};
// 使它的属性表冻结（不能再添加属性）
Object.freeze(a);
try {
  // 本节的示例代码
  a.x = a = {n:2};
}
catch (x) {
  // 异常发生，说明第二次赋值“a.x = ...”中操作的`a`正是原始的变量 a
  console.log('第二次赋值导致异常.');
}
// 第一次赋值是成功的
console.log(a.n); //
```

第二次赋值操作中，将尝试向“原始的变量a”添加一个属性“a.x“，且如果它没有冻结的话，属性“a.x”会指向第一次赋值的结果。

- 有一个新的a产生，它覆盖了原始的变量a，它的值是{n:2}；
- 最左侧的“a.x”的计算结果中的“原始的变量a”在引用传递的过程中丢失了，且“a.x”被同时丢弃。

所以，第二次赋值操作“a.x = …”实际是无意义的。因为它所操作的对象，也就是“原始的变量a”被废弃了。但是，如果有其它的东西，如变量、属性或者闭包等，持有了这个“原始的变量a”，那么上面的代码的影响仍然是可见的。

> 事实上，由于 JavaScript 中支持属性读写器，因此向“a.x”置值的行为总是可能存在“某种执行效果”，而与“a”对象是否被覆盖或丢弃无关。

```js
var a = {n:1}, ref = a;
a.x = a = {n:2};
console.log(a.x); // --> undefined
console.log(ref.x); // {n:2}
```

阅读 JQuery 代码的过程中发现了这一使用模式：

```js
elemData = {}
...
elemData.events = elemData = function(){};
elemData.events  = {};
```

意味着给旧的变量添加一个指向新变量的属性。因此，一个链表是可以像下面这样来创建的：

```js
var i = 10, root = {index: "NONE"}, node = root;
// 创建链表
while (i > 0) {
  node.next = node = new Object;
  node.index = i--;  // 这里可以开始给新 node 添加成员
}
// 测试
node = root;
while (node = node.next) {
  console.log(node.index);
}
```

## export default function() {}：你无法导出一个匿名函数表达式
