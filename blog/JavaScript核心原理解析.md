# JavaScript核心原理解析

## delete 0：JavaScript中到底有什么是可以销毁的

**习惯中的“引用”**

早期的 JavaScript 在推广时，采用传统的数据类型分类即值类型和引用类型，并且，所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的。

但是什么是引用类型呢？在这件事上，JavaScript 偷了个懒，它强行定义了“Object 和 Function 就是引用类型”。这样一来，引用类型和值类型就给开发人员讲清楚了，对象和函数呢，也就可以理解了：它们按引用来传递和使用。

绝大多数情况下，这样解释是可行的。但是到了 delete 运算这里，就不行。因为这样一来，`delete 0` 就是删除一个值，而 `delete x` 就既可能是删除一个值，也可能是删除一个引用。然而，当时 JavaScript 又同时约定：那些在 global 对象上声明的属性，就“等同于”全局变量。于是，这就带来了第三个问题：`delete x` 还可能是删除一个 global 对象上的属性。而它在执行这个操作的时候，看起来却像是一个全局变量（的名字）。

**到底在删除什么？**

```js
delete obj.x
```

`obj.x`既不是之前说过的引用类型，也不是之前说过的值类型，它与`typeof(x)`识别的所有类型都无关。因为，它是一个表达式。所以，`delete` 这个操作的正式语法设计并不是“删除某个东西”，而是“删除一个表达式的结果”：

**表达式的结果是什么？**

在 JavaScript 中，有两个东西可以被执行并存在执行结果值（Result），包括语句和表达式。比如你用`eval()`来执行一个字符串，那么事实上，你执行的是一个语句，并返回了语句的值；而如果你使用一对括号来强制一个表达式执行，那么这个括号运算得到的，就是这个表达式的值。表达式的值，在 ECMAScript 的规范中，称为“引用”。

```js
delete 0
```

事实上是在说：JavaScript 将 0 视为一个表达式，并尝试删除它的求值结果。

所以，现在这里的 0，其实不是值（Value）类型的数据，而是一个表达式运算的结果值（Result）。而在进一步的删除操作之前，JavaScript 需要检测这个 Result 的类型：

- 如果它是值，则按照传统的 JavaScript 的约定返回 true；
- 如果它是一个引用，那么对该引用进行分析，以决定如何操作。

这个检测过程说明，ECMAScript 约定：任何表达式计算的结果（Result）要么是一个值，要么是一个引用。并且需要留意的是，在这个描述中，所谓对象，其实也是值。准确地说，是“非引用类型”。
