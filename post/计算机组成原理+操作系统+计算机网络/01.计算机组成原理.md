# 计算机组成原理

- 概述
  - 发展史
    - 计算机发展的四个阶段
    - 微型计算机的发展历史
  - 分类
    - 超级计算机
    - 大型计算机
    - 迷你计算机(服务器)
    - 工作站
    - 微型计算机
  - 体系结构
    - 冯诺伊曼体系
    - 现代计算机的结构
  - 层次结构
    - 硬件逻辑层
    - 微程序机器层
    - 传统机器层
    - 操作系统层
    - 汇编语言层
    - 高级语言层
    - 应用层
  - 编码集
- 组成
  - 总线
  - 存储器
  - IO设备
  - CPU
  - 指令系统
- 计算
  - 进制转换
  - 定点数
  - 浮点数
  - 原码、补码、反码
  - 四则运算
- 综合实践
  - 双向链表
  - FIFO
  - LFU
  - LRU

## 1. 概述

### 1.1 计算机的发展史

#### 1.1.1 计算机发展的四个阶段

- 第一阶段: 电子管计算机(1946) - 埃尼阿克(ENIAC)
  - 集成度小，空间占用大
  - 功耗高，运行速度慢
  - 操作复杂，更换程序需要接线

  第二次世界大战是电子管计算机产生的催化剂(英国为了解密德国海军的密文)

- 第二阶段: 晶体管计算机(1957) - 来自MIT林肯实验室
  - 集成度相对较高，空间占用相对小
  - 功耗相对较低，运行速度较快
  - 操作相对简单，交互更加方便

  贝尔实验室的三个科学家发明了晶体管

- 第三阶段: 集成电路计算机(1964)
  - 计算机变得更小
  - 功耗变得更低
  - 计算速度变得更快

  德州仪器的工程师发明了集成电路(IC)，计算机具备进入千家万户的条件

- 第四阶段: 超大规模集成电路计算机(1980)
  - 一个芯片集成了上百万的晶体管
  - 速度更快，体积更小，价格更低，更能被大众接受
  - 用途丰富:文本处理、表格处理、高交互的游戏与应用

- 第五个阶段: 未来的计算机
  - 生物计算机: 以蛋白质分子作为主要原材料
    - 体积小，效率高
    - 不易损坏，生物级别的自动修复
    - 不受信号干扰，无热损耗
  - 量子计算机: 遵循量子力学的物理计算机
    - 2013年5月，谷歌和NASA发布D-Wave Two
    - 2017年5月，中国科学院宣布制造出光量子计算机
    - 2019年1月，IBM展示了世界首款商业化量子计算机

#### 1.1.2 微型计算机的发展历史

- 单核CPU:  集成电路的性能，每18-24个月就会提升一倍
  - (1971~1973)500KHz频率的微型计算机(字长8位)
  - (1973~1978)高于1MHz频率的微型计算机(字长8位)
  - (1978~1985)500MHz频率的微型计算机(字长16位)
  - (1985~2000)高于1GHz频率的微型计算机(字长32位)
  - (2000~现在)高于2GHz频率的微型计算机(字长为64位)

- 多核CPU
  - (2005) Intel奔腾系列双核CPU、AMD速龙系列
  - (2006)Intel酷睿四核CPU Intel酷睿系列十六核CPU
  - Intel至强系列五十六核CPU

### 1.2 计算机的分类

- 超级计算机
  - 功能最强、运算速度最快、存储容量最大的计算机
  - 多用于国家高科技领域和尖端技术研究
  - 标记他们运算速度的单位是`TFlop/s`，`1TFlop/s`=每秒一万亿次浮点计算

- 大型计算机
  - 又称大型机、大型主机、主机等
  - 具有高性能，可处理大量数据与复杂的运算
  - 在大型机市场领域，IBM占据着很大的份额

- 迷你计算机(服务器)
  - 也称为小型机，普通服务器
  - 不需要特殊的空调场所
  - 具备不错的算力，可以完成较复杂的运算

- 工作站
  - 高端的通用微型计算机，提供比个人计算机更强大的性能
  - 类似于普通台式电脑，体积较大，但性能强劲

- 微型计算机
  - 又称为个人计算机，是最普通的一类计算机
  - 从构成的本质上来讲，个人计算机与前面的分类无异

### 1.3 计算机的体系与结构

- 冯诺伊曼体系（现代计算机都是冯诺依曼机）
  - 特性：
    - 将程序指令和数据一起存储的计算机设计概念结构
    - 必须有一个存储器
    - 必须有一个控制器
    - 必须有一个运算器
    - 必须有输入设备
    - 必须有输出设备
  - 瓶颈
    - CPU和存储器速率之间的问题无法调和
    - CPU经常空转等待数据传输
- 现代计算机的结构
  - 现代计算机在冯诺依曼体系结构基础上进行修改
  - 解决CPU与存储设备之间的性能差异问题
  - 以存储器为核心

### 1.4  计算机的层次与编程语言

- 程序翻译与程序解释
  - 人类语言 -> 计算机语言， 需要进行语言之间的转换（较为高级的计算机语言L1，较为低级的L0）
  - 计算机执行的指令都是L0
  - 翻译过程（编译型）生成新的L0程序，解释过程（解释型）不生成新的L0程序
  - 解释过程由L0编写的解释器去解释L1程序

**编译型：**

较为高级的计算机语言L1（ L1进行程序逻辑描述） —生成(编译器)—> 较为低级的计算机语言L0（计算机实际执行的语言）

以java为例，执行过程是这样的 java程序 -编译-> JVM字节码（JVM虚拟机） -解释-> 机器码

**解释型：**

较为高级的计算机语言L1（ L1进行程序逻辑描述） —作为输入—> 使用L0语言实现另一个程序（解释器）—转换—> 较为低级的计算机语言L0

- 计算机的层次与编程语言

![](http://cdn-blog.liusixin.cn/FtYpYS9p3O0E7xLQet65HbPaQslP)

- 硬件逻辑层
  - 门、触发器等逻辑电路组成
  - 属于电子工程的领域
- 微程序机器层
  - 编程语言是微指令集
  - 微指令所组成的微程序直接交由硬件执行
- 传统机器层
  - 编程语言是CPU指令集(机器指令)
  - 编程语言和硬件是直接相关
  - 不同架构的CPU使用不同的CPU指令集
- 操作系统层
  - 向上提供了简易的操作界面
  - 向下对接了指令系统，管理硬件资源
  - 操作系统层是在软件和硬件之间的适配层
- 汇编语言层
  - 编程语言是汇编语言
  - 汇编语言可以翻译成可直接执行的机器语言
  - 完成翻译的过程的程序就是汇编器
- 高级语言层
  - 编程语言为广大程序员所接受的高级语言
  - 高级语言的类别非常多，由几百种
  - 常见的高级语言有:Python、Java、C/C++、Golang等
- 应用层
  - 满足计算机针对某种用途而专门设计

### 1.5 计算机的计算单位

- 容量单位
  - 在物理层面，高低电平记录信息
  - 理论上只认识0/1两种状态
  - 0/1能够表示的内容太少了，需要更大的容量表示方法
  - 0/1称为bit(比特位)
  - 字节:1Byte=8bits

|          |  bit   | Byte  |   KB   |    MB    |    GB     |   TB   |   PB   |    EB    |
| :------- | :----: | :---: | :----: | :------: | :-------: | :----: | :----: | :------: |
| 名字     | 比特位 | 字节  | 千字节 |  兆字节  |  吉字节   | 太字节 | 拍字节 |  艾字节  |
| 比例     |   -    | 8bits | 1024B  |  1024KB  |  1024MB   | 1024GB | 1024TB |  1024EB  |
| 常见设备 | 门电路 |   -   | 寄存器 | 高速缓存 | 内存/硬盘 |  硬盘  | 云硬盘 | 数据仓库 |

- 速度单位
  - 网络速度
    - 100M = 100M/s

为什么电信拉的100M光纤，测试峰值速度只有12M每秒?

```bash
# 网络常用单位为(Mbps)
100M/s = 100Mbps = 100Mbit/s
100Mbit/s = (100/8)MB/s = 12.5MB/s
```

- CPU频率
  - CPU的速度一般体现为CPU的时钟频率
  - CPU的时钟频率的单位一般是赫兹(Hz)
  - 主流CPU的时钟频率都在2GHz以上
  - Hz其实就是秒分之一，它是每秒中的周期性变动重复次数的计量
  - 并不是描述计算机领域所专有的单位
  - `2GHz = 2*1000^3Hz = 每秒20亿次`

### 1.6 计算机的字符与编码集

- 字符编码集的历史
  - ASCII码
    - 使用7个bits就可以完全表示ASCII码
    - 包含95个可打印字符
    - 33个不可打印字符(包括控制字符) `𝟑𝟑 + 𝟗𝟓 = 𝟏𝟐𝟖 = 𝟐^𝟕`
  - Extended ASCII码(第一次对ASCII码进行扩充，`7bits => 8bits`)
    - 常见数学运算符
    - 带音标的欧洲字符
    - 其他常用符、表格符等
  - 字符编码集的国际化
    - 欧洲、中亚、东亚、拉丁美洲国家的语言多样性
    - 语言体系不一样，不以有限字符组合的语言
    - 中国、韩国、日本等的语言最为复杂
- 中文编码集
  - 《信息交换用汉字编码字符集——基本集》
    - 一共收录了 7445 个字符
    - 包括 6763 个汉字和 682 个其它符号
  - 《汉字内码扩展规范》
    - 向下兼容GB2312，向上支持国际ISO标准
    - 收录了21003个汉字，支持全部中日韩汉字
  - Unicode:统一码、万国码、单一码
    - Unicode定义了世界通用的符号集，UTF-*实现了编码
    - UTF-8以字节为单位对Unicode进行编码

 Windows系统默认使用GBK编码，编程推荐使用UTF-8编码

## 2. 组成

- 计算机的总线与IO设备
  - 计算机的总线
  - 计算机的输入/输出设备
- 计算机的存储器
  - 计算机的存储器概览
    - 计算机的主存储器与辅助存储器
    - 计算机的高速存储器
- 计算机的CPU
  - 计算机的指令系统
  - 计算机的控制器
  - 计算机的运算器
  - 指令执行过程

### 2.1 计算机的总线

- 总线的概述
  - 提供了对外连接的接口
  - 不同设备可以通过USB接口进行连接
  - 连接的标准，促使外围设备接口的统一
  - 解决不同设备之间的通信问题
- 总线的分类
  - 片内总线
    - 芯片内部的总线
    - 寄存器与寄存器之间
    - 寄存器与控制器、运算器之间
  - 系统总线（ CPU、主内存、IO设备、各组件之间的信息传输线）
    - 数据总线(一般与CPU位数相同(32位、64位))
      - 双向传输各个部件的数据信息
      - 数据总线的位数(总线宽度)是数据总线的重要参数
    - 地址总线(地址总线位数=n，寻址范围:0~𝟐𝒏)
      - 指定源数据或目的数据在内存中的地址 - 地址总线的位数与存储单元有关
    - 控制总线
      - 控制总线是用来发出各种控制信号的传输线
      - 控制信号经由控制总线从一个组件发给另外一个组件
      - 控制总线可以监视不同组件之间的状态(就绪/未就绪)

### 2.2 计算机的输入输出设备

- 常见的输入输出设备
- 输入输出接口的通用设计
- CPU与IO设备的通信

#### 2.2.1 常见的输入输出设备

- 字符输入设备
  - 键盘
    - 薄膜键盘
    - 机械键盘
      - 黑轴
      - 红轴
      - 青轴
      - 茶轴
    - 电容键盘
- 图像输入设备
  - 鼠标
  - 数位板
  - 扫描仪

#### 2.2.2 输入输出接口的通用设计

向设备发送数据？读取数据？设备有没有被占用？设备是否已经启动？设备是否已经连接？

- 数据线
  - 是I/O设备与主机之间进行数据交换的传送线 - 单向传输数据线
  - 双向传输数据线
- 状态线
  - IO设备状态向主机报告的信号线
  - 查询设备是否已经正常连接并就绪
  - 查询设备是否已经被占用
- 命令线
  - CPU向设备发送命令的信号线
  - 发送读写信号
  - 发送启动停止信号
- 设备选择线
  - 主机选择I/O设备进行操作的信号线
  - 对连在总线上的设备进行选择

#### 2.2.3 CPU与IO设备的通信

 CPU速度与IO设备速度不一致

- 程序中断
  - 当外围IO设备就绪时，向CPU发出中断信号
  - CPU有专门的电路响应中断信号
- DMA(直接存储器访问)
  - DMA直接连接主存与IO设备
  - DMA工作时不需要CPU的参与

CPU -> 主存 -> DMA -> IO设备，当主存与IO设备交换信息时，不需要中断CPU 可以提高CPU的效率

### 2.3 存储器

- 存储器的分类
  - 按存储介质分类
    - 半导体存储器
      - 内存
      - U盘
      - 固态硬盘
    - 磁存储器
      - 磁带
      - 磁盘
  - 按存取方式分类
    - 随机存储器(RAM)
      - 随机读取
      - 与位置无关
    - 串行存储器
      - 与位置有关
      - 按顺序查找
    - 只读存储器(ROM)
      - 只读不写
- 存储器的层次结构
  - 缓存
    - 特点
      - 速度快
      - 位格高
    - 原理:局部性原理，局部性原理是指CPU访问存储器时，无论是存取指令 还是存取数据，所访问的存储单元都趋于聚集在一个 较小的连续区域中。
    - 实现:在CPU与主存之间增加一层速度快(容量小)的Cache
    - 目的:解决主存速度不足的问题
  - 主存
    - 特点
      - 速度适中
      - 位格适中
    - 原理:局部性原理
    - 实现:主存之外增加辅助存储器(磁盘、SD卡、U盘等)
    - 目的:解决主存容量不足的问题
  - 辅存
    - 速度慢
    - 位格低

#### 2.3.1 计算机的主存储器与辅助存储器

- 主存储器——内存
  - RAM(随机存取存储器:Random Access Memory)
  - AM通过电容存储数据，必须隔一段时间刷新一次
  - 如果掉电，那么一段时间后将丢失所有数据
- 辅助存储器——磁盘
  - 特点
    - 表面是可磁化的硬磁特性材料
    - 移动磁头径向运动读取磁道信息
  - 原理
    - 先来先服务算法
    - 最短寻道时间优先
      - 与磁头当前位置有关
      - 优先访问离磁头最近的磁道
    - 扫描算法(电梯算法)
      - 每次只往一个方向移动
      - 到达一个方向需要服务的尽头再反方向移动
    - 循环扫描算法

#### 2.3.2  计算机的高速缓存

- 高速缓存的工作原理
  - 字: 是指存放在一个存储单元中的二进制代码组合
  - 字块: 存储在连续的存储单元中而被看作是一个单元的一组字
  - 命中率是衡量缓存的重要性能指标
  - 理论上CPU每次都能从高速缓存取数据的时候，命中率为1


一个字有32位，一个字块共B个字，主存共M个字块，`B*M = 主存总字数`，`B*M*32 = 主存总容量(bits)`

字的地址包含两个部分，前m位指定字块的地址，后b位指定字在字块中的地址

- 高速缓存的替换策略
  - 随机算法
  - 先进先出算法(FIFO)
    - 把高速缓存看做是一个先进先出的队列
    - 优先替换最先进入队列的字块
  - 最不经常使用算法(LFU)
    - 优先淘汰最不经常使用的字块
    - 需要额外的空间记录字块的使用频率
  - 最近最少使用算法(LRU)
    - 优先淘汰一段时间内没有使用的字块
    - 有多种实现方法，一般使用双向链表
    - 把当前访问节点置于链表前面(保证链表头部节点是最近使用的)

### 2.4 计算机的指令系统

- 机器指令的形式
  - 操作码: 指明指令所要完成的操作，操作码的位数反映了机器的操作种类
  - 地址码: 直接给出操作数或者操作数的地址，分三地址指令、二地址指令和一地址指令
- 机器指令的操作类型
  - 等待指令
  - 停机指令
  - 空操作指令
  - 中断指令

- 机器指令的寻址方式
  - 指令寻址
    - 顺序寻址
    - 跳跃寻址
  - 数据寻址
    - 立即寻址
      - 指令直接获得操作数
      - 无需访问存储器
    - 直接寻址
      - 直接给出操作数在主存的地址
      - 寻找操作数简单，无需计算数据地址
    - 间接寻址
      - 指令地址码给出的是操作数地址的地址 - 需要访问一次或多次主存来获取操作数

| 寻址方式 |       优点       |             缺点             |
| :------- | :--------------: | :--------------------------: |
| 立即寻址 |      速度快      | 地址码位数限制操作数表示范围 |
| 直接寻址 |  寻找操作数简单  | 地址码位数限制操作数寻址范围 |
| 间接寻址 | 操作数寻址范围大 |           速度较慢           |

## 3. 计算

- 进制运算的基本知识
  - 进制运算的基础
- 二进制数据的表示方法
  - 有符号数与无符号数
  - 二进制的反码表示法
  - 二进制的补码表示法
  - 小数的二进制补码表示
- 二进制数据的运算
  - 定点数与浮点数
  - 浮点数的加减法运算
  - 定点数的加减法运算
  - 浮点数的乘除法运算

### 3.1 进制运算的基础

#### 3.1.1 进制概述

- 进位制是一种记数方式，亦称进位计数法或位值计数法
- 有限种数字符号来表示无限的数值
- 使用的数字符号的数目称为这种进位制的基数或底数
- 二进制
- 八进制
- 十六进制
  - [0-9]和A、B、C、D、E、F
- 二十进制
  - 玛雅文明的玛雅数字
  - 因努伊特的因努伊特数字
- 六十进制
  - 时间、坐标、角度等量化数据

**八进制&十六进制**

计算机喜欢二进制，但是二进制表达太长了，使用大进制位可以解决这个问题，八进制、十六进制满足2的n次方的要求

| 二进制            |   八进制    |  十六进制  |
| :---------------- | :---------: | :--------: |
| 1024=0b1000000000 | 1024=0o2000 | 1024=0x400 |

#### 3.1.2 二进制运算的基础

- 正整数N，基数为r
- 𝑁 = 1024： 𝑁 = 1∗10^3 +2∗10^1 +4
- 𝑁 = 10000000000： 𝑁 = 1 ∗ 2^10

```bash
# 整数
𝑁 = 01100101 = 1∗2^6 + 1∗2^5 + 1∗2^2 + 1 = 101
𝑁 = 11101101 = 1∗2^7 + 1∗2^6 + 1∗2^5 + 1∗2^3 + 1∗2^2 + 1 = 237
```

**(整数)十进制转换二进制:重复相除法**

| 重复除以2 | 得商  | 取余数 |
| :-------- | :---: | :----: |
| 101/2     |  50   |   1    |
| 50/2      |  25   |   0    |
| 25/2      |  12   |   1    |
| 12/2      |   6   |   0    |
| 6/2       |   3   |   0    |
| 3/2       |   1   |   1    |
| 1/2       |   0   |   1    |

`𝑁= 01100101 =1∗2^6+1∗2^5+1∗2^2+1=101`

``` bash
# 小数
𝑁 = 0.11001 = 1∗2^−1 + 1∗2^−2 + 1∗2^−5 = 0.78125 = 25/32
𝑁 = 0.01011 = 1∗2^−2 + 1∗2^−4 + 1∗2^−5 = 0.34375 = 11/32
```

**(小数)十进制转换二进制:重复相乘法**

| 重复乘以2 |     得积     |  取1  |
| :-------- | :----------: | :---: |
| 25/32     | 50/32=1+9/16 |   1   |
| 9/16      | 18/16=1+1/8  |   1   |
| 1/8       |  1/4=0+1/4   |   0   |
| 1/4       |  1/2=0+1/2   |   0   |
| 1/2       |    1=1+0     |   1   |

`𝑁 = (0.11001) = 1∗2^−1 + 1∗2^−2 + 1∗2^−5 = 0.78125 = 25/32`

### 3.2 二进制数据的表示方法

#### 3.2.1  有符号数与无符号数

+表示正数，-表示负数

```bash
#  使用0表示正数，使用1表示负数
+237=011101101
-237=111101101
```

怎么判断他是数字位还是符号位呢?

**原码表示法**

- 使用0表示正数、1表示负数
- 规定符号位位于数值第一位
- 表达简单明了，是人类最容易理解的表示法

| 0 (符号位)    |   0   |   0   | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 0 | 1 |
| 1 (符号位)   |   0   |   0   | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 0 | 1 |

`+237=011101101，-237=111101101`

 0有两种表示方法:00、10。原码进行运算非常复杂，特别是两个操作数符号不同的时候

- 判断两个操作数绝对值大小
- 使用绝对值大的数减去绝对值小的数
- 对于符号值，以绝对值大的为准

 希望找到不同符号操作数更加简单的运算方法，希望找到使用正数代替负数的方法，使用加法操作代替减法操作，从而消除减法

#### 3.2.2  二进制的补码表示法

```bash
#  正数
𝑥 = 𝑥 (2𝑛 > 𝑥 ≥ 0)
# 负数
𝑥 = 2^(𝑛 + 1) + 𝑥 (0 > 𝑥 ≥ −2^𝑛)
```

**例子1: n=4，x=13，计算x的二进制原码和补码**

```bash
# 原码
x = 0,1101
# 补码
x = 0,1101
```

**例子2: x=-13，计算x的二进制原码和补码**

```bash
# 原码
x = 1,1101
# 补码
x = 2^(𝑛 + 1) + 𝑥 = 2^(4 + 1) − 13 = 100000 − 1101 = 10011
# 10011 第一个1为符号位
x = 1,0011
```

**例子3: x=-1，计算x的二进制原码和补码**

```bash
# 原码
x = 1,0001
# 补码
x = 2^(𝑛 + 1) + 𝑥 = 2^(4 + 1) − 1 = 100000 − 0001 = 11111
# 11111 第一个1为符号位
x = 1,1111
```

在计算补码的过程中，还是使用了减法!!

#### 3.2.3 二进制的反码表示法
